#!/bin/bash
#
# create summarys of your computations 
#
# script is not fully tested. Use at your own risk
# please report any bugs and suggestions via mail or during cigarette breaks
#




# difine variables
VERSION="0.2" # basic ORCA implementation done
USERFILEPATH=`whoami`
DIR=`pwd`
HOST=`ident_host | awk '{print $1}'`
HOSTIP=`ident_host | awk '{print $2}'`
#default settings: these may be changed by some arguments
CSVFILEFILEPATH="summary.csv"
CSVFILEFILEPATH_BKUP="summary_bkup.csv"
CSVDELIM=";"
DECISEP="."
SCRIPTDIR=`dirname $(readlink -f ${0})`
MAXFILES=25 # maximal files summary will read without extra user input
DEPTH=all #depth of search -1=all 0=current n=n subfolders
VERBOSITY=0 # verbosity of the output on terminal
SI_vers=0 # which kind of SI file is written ( Default: 0 = none )
VARFILE=all # given output-file for analysis ( Default: all ) #TIZIAN  




function prnt_error {
echo -e  "\033[0;31m ERROR ! stopping script \033[0m "
}

function prnt_warning {
echo -e "\033[1;33m WARNING ! \033[0m "
}

function prnt_ok {
echo -e -n "\033[0;32m OK: \033[0m "
}

## here schould be some sort of check for arguments

while getopts ":hd:s:cn:vi:f:" OPTION; do	#TIZIAN
  case $OPTION in
    h) 
	vim $SCRIPTDIR/help_summary.txt  
	exit
	;;
	d)
	CSVDELIM=$OPTARG
	;;
	s)
	DECISEP=$OPTARG
	;;
	c)
	DEPTH=0
	;;
	n)
	DEPTH=$OPTARG
	;;
	v)
	VERBOSITY=1
	;;
	i)
	SI_vers=$OPTARG
	;;
	f)					#TIZIAN
	VARFILE=$OPTARG
	;;
    \?)
	prnt_error
    echo "Invalid option: -$OPTARG" >&2
	echo "For Help type: sumary -h"
	exit
    ;;
  esac
done



# show welcome message
echo -n "summary version $VERSION    "

#Defining the depth of search (-c -n) or output file (-f)

 case $VARFILE in								#TIZIAN
         all)
         case $DEPTH in
                 all)
                 LIST=`find ! -name 'slurm*.out' -name "*.out"`
                 echo "... searching in all subfolders"
                 ;;
                 0)
                 LIST=`find -maxdepth 1 ! -name 'slurm*.out' -name "*.out"`
                 echo "... searching in only the currend folder"
                 ;;
                 *)
                 echo "... searching this and $DEPTH subfolders"
                 DEPTH=`echo "$DEPTH + 1"  | bc`
                 LIST=`find -maxdepth $DEPTH ! -name 'slurm*.out' -name "*.out"`
                 ;;
         esac
         LISTARR=($LIST)
         ;;
         *)									#TIZIAN 
         echo "... search for file: "$VARFILE""
         LIST=`find -maxdepth 1 ! -name 'slurm*.out' -name "$VARFILE"`
         LISTARR=($LIST)
         ;;
 esac



# asks for user reply if too much files are found

if [ ${#LISTARR[@]} -gt $MAXFILES ]
then
	prnt_warning
	echo "found a large amount of OUT files"
	echo "${#LISTARR[@]} / $MAXFILES"
	read -p "Do you want to proceed ? " -n 1 -r 
		case $REPLY in
        [Yy]* ) echo "  OK";;
        [Nn]* ) echo ""; exit;;
        * ) echo "  Please answer Y or N."; exit ;;
        esac
else echo "found ${#LISTARR[@]} OUT files ... starting now"
fi


######################################################
#            Functions for reading various stuff

function format_strings { # formats stuff like the full path to the file, the dir in which the file is stored and the filename
FILENAME=`echo " $FILEPATH" | sed -e 's@\/@ @g' | awk '{print $NF}'`
FILENAMFORMATTED=`echo "$FILENAME" | cut -c -24 `

FULLPATH=$FILEPATH 
}

function ident_prog { # identify the programm (gaussian, orca, ...) that created this OUT file
#orca:
FILEHEAD=`head -3 $FILEPATH `
IDENTORCA=`echo "$FILEHEAD"| grep -c "        * O   R   C   A *"`
IDENTGAUSSIAN=`echo "$FILEHEAD"| grep -c " Entering Gaussian System, Link 0"`

PROGID=0
PROGNAME="none"

if [ "$IDENTORCA" = "0" ] & [ "$IDENTGAUSSIAN" = "1" ]
	then
	PROGNAME="Gaussian"
fi 

if [ "$IDENTORCA" = "1" ] & [ "$IDENTGAUSSIAN" = "0" ]
	then
	PROGNAME="ORCA"
fi
}

function find_methode { # gives the used Method
if [ $PROGNAME = "Gaussian" ]
then
TEST=`grep -m 1 "GINC-" $FILEPATH `
	if [ -n "$TEST" ]
	then
	RAW=`grep -m 1 "GINC-" $FILEPATH | sed -e 's.\\\. .g'`
	METH=` echo $RAW | awk '{print $5}'`
	BASIS=`echo $RAW | awk '{print $6}'`
	fi
fi


if [ $PROGNAME = "ORCA" ]
then
RAW=`grep "| " $FILEPATH  | grep "!"`
METH=` echo $RAW | awk '{print $4}'`
BASIS=`echo $RAW | awk '{print $5}'`
fi
}

function find_coords {



NATOMS=`grep -m 1 "NAtoms=" $FILEPATH | awk '{print $2}' | sed -e 's/ //g'`

COORDS_RAW=`grep -i -A $NATOMS "Redundant internal coordinates found in file." $FILEPATH ` #read the coordinates used for the frequency computation

COORDS=`echo "$COORDS_RAW" | sed -e 1d | sed -e 's/,0,/,/g' | sed -e 's/ //g '  | sed -e 's/,/ /g' ` # some nice formatting

COORDS_new=`printf '%-3s\t%-14s\t%-14s\t%-14s\n' $COORDS`

#| sed -e 's/,-/    -/g' | sed -e 's/,/     /g' | sed -e "1ipufferzeile" | sed -e "1i$NATOMS" | sed -e 's/pufferzeile//g'
}

function find_energ { 

if [ $PROGNAME = "Gaussian" ] 
then
TEST=`grep -m 1 -c "SCF Done:  " $FILEPATH`
	if [ "$TEST" != 0 ]
	then
	ENERG_EL=`tac $FILEPATH | grep -m 1 "SCF Done:  " | awk '{print $5}'`
	fi
fi

if [ $PROGNAME = "ORCA" ]
then
TEST=`grep -m 1 -c "FINAL SINGLE POINT ENERGY" $FILEPATH`
	if [ "$TEST" != 0 ]
	then
	ENERG_EL=`tac $FILEPATH | grep -m 1 "FINAL SINGLE POINT ENERGY" | awk '{print $5}'`
	fi
#	ENERG_EL=`tac $FILEPATH | grep -m 1 "FINAL SINGLE POINT ENERGY"  | awk '{print $5}'`
fi

}

function find_ther_corr { # finds the themal corrections to electronic Energy
 
 
if [ $PROGNAME = "Gaussian" ]
then
TEST=`grep -c -i "Zero-point correction=" $FILEPATH `
	if [ "$TEST" != "0" ]
	then
	
	TEST=`grep -m 1 -A 8 "Zero-point correction=" $FILEPATH`
	
	ZPVE=`       echo -e "$TEST"| grep "Zero-point correction=" | awk '{print $3}'`	
	ENERG_THERM=`echo -e "$TEST"| grep "Thermal correction to Energy=" | awk '{print $5}'`
	ENTHALPY=`  echo -e "$TEST" | grep "Thermal correction to Enthalpy=" | awk '{print $5}'`
	GIBBS=`    echo  -e "$TEST" | grep "Thermal correction to Gibbs Free Energy=" | awk '{print $7}'`
	
	# version discarded to enhance readability
#	RAW=`grep -A 8 "Zero-point correction=" $FILEPATH| awk 'NF>1{print $NF}'`
#	RAWARRAY=($RAW)
# 
#	ENERG_THERM=${RAWARRAY[1]}
#	ENTHALPY=${RAWARRAY[2]}
#	GIBBS=${RAWARRAY[3]}
	fi
fi


if [ $PROGNAME = "ORCA" ]
then
TEST=`grep -c "Analytical frequency calculation" $FILEPATH `
	if [ "$TEST" != "0" ]
	then
	
	# the Following Correctiosn can be found directly in the output. analogous to the Corrections found in Gaussian outputs
	ZPVE=`grep "Zero point energy" $FILEPATH | awk '{print $5}'`
	ENERG_THERM=`grep "Total correction" $FILEPATH | awk '{print $3}'`
	GIBBS=`grep "G-E(el)" $FILEPATH | awk '{print $3}'`
	
	# ORCA adds up the coorections subsequently to on another.
	# The "Thermal Enthalpy correction" has to be addet to the "Total correction"  (ZPVE + thermal correction)
	# to yield the same correction as stated by gaussian (based on Electronic energy )
	#[ORCA gives the enthalpy correction based on the Total free energy]
	TOTALCORRECTION=`grep "Total correction" $FILEPATH | awk '{print $3}'`
	ENTHALPYCORRECTION=`grep "Thermal Enthalpy correction" $FILEPATH | awk '{print $5}'`
	ENTHALPY=`echo "$TOTALCORRECTION + $ENTHALPYCORRECTION | bc" `


	fi
fi


}

function find_Nimag {

if [ $PROGNAME = "Gaussian" ]
then
TEST=`grep -i -m 1 "imaginary frequencies (negative Signs" $FILEPATH`
	if [ -z "$TEST" ]
	then 
	IMAG="0"
	else 
	IMAG=`grep -i -m 1 "imaginary frequencies (negative Signs" $FILEPATH | awk '{print $2}'`
	fi
fi

if [ $PROGNAME = "ORCA" ]
then

IMAG=`grep -c  "imaginary mode" $FILEPATH ` 

fi


}

function find_NTerm {

if [ $PROGNAME = "Gaussian" ]
then
	NTERM=`grep -c "Normal termination of Gaussian" $FILEPATH`
fi

if [ $PROGNAME = "ORCA" ]
	then
	NTERM=`grep -c "ORCA TERMINATED NORMALLY" $FILEPATH`
fi



}

function find_charge {

if [ $PROGNAME = "Gaussian" ] 
	then
	CHARGE=`grep -m 1 "Charge =" $FILEPATH | awk '{print $3}'`
	MULITPL=`grep -m 1 "Charge =" $FILEPATH | awk '{print $6}'`

fi

if [ $PROGNAME = "ORCA" ]
	then
	CHARGE=`grep -m 1 "Total Charge" $FILEPATH | awk '{print $5}'`
	MULITPL=`grep -m 1 "Multiplicity" $FILEPATH | awk '{print $5}'`
fi




}

function find_version {

if [ $PROGNAME = "Gaussian" ]
then
	RAW=`grep -m 1 -A 2 "Cite this work as:" $FILEPATH`
	PROG=`echo $RAW | awk '{print $5 $6}' | sed 's/,//g'`
	REV=`echo $RAW | awk '{print $8}' | sed 's/,//g'`
fi

if [ $PROGNAME = "ORCA" ]
then
	RAW=`grep "Program Version" $FILEPATH`
	REV=`echo $RAW | awk '{print $3}'`
	PROG_RAW=`echo $REV | sed 's@\.@ @g' | awk '{print $1}'`
	PROG=`echo " $PROGNAME $PROG_RAW "`
	
fi


}

function find_runtime {

if [ "$PROGNAME" = "Gaussian" ]
	then
	TEMP=`tail -n 7 $FILEPATH `
	RUNTIME=`echo "$TEMP" | grep "Elapsed time" | awk '{print $3":"$5":"$7":" $9}'`
	
	NT=`echo "$TEMP" | grep -c "Normal termination of Gaussian" `
	ET=`echo "$TEMP" | grep -c "Error termination request processed"`
	
	if [ "$NT" = "1" ]
		then
		JOBSTATE="F-NT"
		elif [ "$ET" = "1" ]
		then
		JOBSTATE="F-ET"
		NOTES+="Error_termination"
		else
		JOBSTATE="unknown"
		NOTES+="Job_running_or_crashed"
	fi
	
fi

if [ $PROGNAME = "ORCA" ]
then
	TEMP=`tail -n 7 $FILEPATH `
	RUNTIME=`echo "$TEMP" | grep "TOTAL RUN TIME:" | awk '{print $4 ":" $6 ":" $8 ":" $10 "." $12}'`

	NT=`echo "$TEMP" | grep -c "ORCA TERMINATED NORMALLY" `
	#ET=`echo "$TEMP" | grep -c "Error termination request processed"`
	#had no examples at hand: inserted for later fix
	if [ "$NT" = "1" ]
		then
		JOBSTATE="F-NT"
		elif [ "$ET" = "1" ]
		then
		JOBSTATE="F-ET"
		NOTES+="Error_termination"
		else
		JOBSTATE="unknown"
		NOTES+="Job_running_or_crashed"
	fi
fi

}

function reset_vars { # set all variables to NA to resolve issues in console output 
NA="-"

METH="$NA" 
BASIS="$NA" 
ENERG_EL="$NA" 
ZPVE="$NA" 
ENERG_THERM="$NA" 
ENTHALPY="$NA" 
GIBBS="$NA" 
IMAG="$NA" 
NTERM="$NA" 
PROG="$NA" 
REV="$NA" 
RUNTIME="$NA" 
NTERM="$NA" 
IMAG="$NA" 
}

function gen_SI_v1 {

find_charge
find_coords


echo -e  "Nummer: \t\t " >> SI.txt
echo -e  "Dateiname: \t $FILENAMFORMATTED" >> SI.txt
echo -e  "" >> SI.txt
echo -e  "E(el.) / hartree : \t $ENERG_EL" >> SI.txt
echo -e  "Methode: $METH / $BASIS" >> SI.txt
echo -e  "" >> SI.txt
echo -e  "Thermische Korrekturen / hartree" >> SI.txt
echo -e  "ZPVE:  $ZPVE   " >> SI.txt
echo -e  "E(therm.): $ENERG_THERM" >> SI.txt
echo -e  "H(korr.): $ENTHALPY" >> SI.txt
echo -e  "G(korr.): $GIBBS" >> SI.txt
echo -e  "Imaginäre Frequenzen:  $IMAG" >> SI.txt
echo -e  "" >> SI.txt
echo -e  "Ladung: $CHARGE   Multiplizität: $MULITPL " >> SI.txt
echo -e  "Koordinaten (X, Y, Z) / Angström " >> SI.txt
echo -e  "$COORDS_new" >> SI.txt
echo -e  "" >> SI.txt
echo -e  "" >> SI.txt
echo -e  "" >> SI.txt
echo -e  "" >> SI.txt


NOTES+="SI_written_(txt)"

# $ENERG_THERM $ENTHALPY $GIBBS $IMAG
}

function gen_SI_v2 {

find_charge
find_coords

COORDS_CSV=`echo "$COORDS_RAW" | sed -e 1d | sed -e 's/,0,/,/g' | sed -e 's/ //g '  | sed -e 's/,/;/g' `

echo -e  "Nummer: ; " >> SI.CSV
echo -e  "Dateiname: ; $FILENAMFORMATTED" >> SI.CSV
echo -e  "" >> SI.CSV
echo -e  "E(el.) / hartree : ; $ENERG_EL" >> SI.CSV
echo -e  "Methode: ; $METH / $BASIS" >> SI.CSV
echo -e  "" >> SI.CSV
echo -e  "Thermische Korrekturen / hartree" >> SI.CSV
echo -e  "ZPVE: ; $ZPVE ; E(therm.): ; $ENERG_THERM" >> SI.CSV
echo -e  "H(korr.): ; $ENTHALPY ;G(korr.): ; $GIBBS" >> SI.CSV
echo -e  "Imaginäre Frequenzen: ; $IMAG" >> SI.CSV
echo -e  "" >> SI.CSV
echo -e  "Ladung:  ; $CHARGE ; Multiplizität: ; $MULITPL " >> SI.CSV
echo -e  "Koordinaten (X, Y, Z) / Angström " >> SI.CSV
echo -e  " $COORDS_CSV " >> SI.CSV
echo -e  "" >> SI.CSV
echo -e  "" >> SI.CSV
echo -e  "" >> SI.CSV
echo -e  "" >> SI.CSV


NOTES+="SI_written_(CSV)"

}

function gen_SI_v3 {

find_charge
find_coords

COORDS_TAB1=`echo "$COORDS_RAW" | sed -e 1d | sed -e 's/,0,/,/g' | sed -e 's/ //g '  | sed -e 's/,/ /g' `
COORDS_TAB=`printf '%-3s\t%-14s\t%-14s\t%-14s\n' $COORDS_TAB1`


echo -e  "Number in this Plublication: $FILENAMFORMATTED  " >> SI.TXT
echo -e  "" >> SI.TXT
echo -e  "Energy \t\t\t Hartree" >> SI.TXT
echo -e  "E $METH/$BASIS \t$ENERG_EL" >> SI.TXT
echo -e  "E @CC-SP \t\t " >> SI.TXT
echo -e  "E @SMD \t\t " >> SI.TXT
echo -e  "ZPVE: \t\t\t$ZPVE " >> SI.TXT
echo -e  "@H(korr.): \t\t$ENTHALPY " >> SI.TXT
echo -e  "@G(korr.): \t\t$GIBBS " >> SI.TXT
echo -e  "number of imaginary frequencies: \t$IMAG" >> SI.TXT
echo -e  "" >> SI.TXT
echo -e  "$CHARGE $MULITPL " >> SI.TXT
echo -e  "$COORDS_TAB " >> SI.TXT
echo -e  "" >> SI.TXT
echo -e  "" >> SI.TXT
echo -e  "" >> SI.TXT
echo -e  "" >> SI.TXT


NOTES+="SI_written_(TXT)"

}


######################################################
# initialisation of the *.csv files

echo "summary" > $CSVFILEFILEPATH #
echo "user;$USERFILEPATH" >> $CSVFILEFILEPATH
echo "directory;$DIR" >> $CSVFILEFILEPATH
echo "host;$HOST" >> $CSVFILEFILEPATH
echo "host IP;$HOSTIP" >> $CSVFILEFILEPATH
echo "Hartree in kcal/mol;627.5096080305927; REF: https://www.weizmann.ac.il/oc/martin/tools/hartree.html" >> $CSVFILEFILEPATH
echo " " >> $CSVFILEFILEPATH

TABLEHEAD="Filepath;filename;method; basisset; E(el); ZP corr.; E corr.; H corr.; G corr.; imaginary frequencies; Normal terminations; programm; Revison; Runtime; Notes"

echo "$TABLEHEAD" >> $CSVFILEFILEPATH

######################################################


case $SI_vers in # checking for valid SI version
	0) # no SI file is written (default)
	;;
	1) # SImple textfile
	echo " " > SI.txt
	;;
	2) #SI in CSV format
	echo " SI generated with summary " > SI.CSV
	;;
	3) #SI in TXT format in english
	echo " SI generated with summary " > SI.TXT
	;;
	*)
	prnt_warning 
	echo "unknown SI version"
	echo "no Si file will be generated" 
	SI_vers=0
	;;
esac



#table headers for console output
case $VERBOSITY in
	0)
	echo "      FILEPATH            |  E(SCF)    |  ZP      | G(korr)   |NT |IF |Program   |   notes"
	echo "--------------------------+------------+----------+-----------+---+---+----------+----------- "
	#     8_PBE0_D3_def2SVp_stacke  | -          | -        | -         | 0 | 0 | Gaussian | Job_running_or_crashed
	;;
	1)
	echo "$ENERG_EL $ZPVE $ENERG_THERM $ENTHALPY $GIBBS" #TIZIAN
	;;
esac




# actuale magic happens here
for FILEPATH in "${LISTARR[@]}" ; do

NOTES=""

reset_vars


ident_prog
format_strings
find_methode
find_energ
find_ther_corr
find_Nimag
find_NTerm
find_version
find_runtime
#FILEPATH=`echo $FILEPATH | sed -e 's/\.//g' `



#output to SI-file
case $SI_vers in # checking for valid SI version
	0) # no SI file is written (default)
	;;
	1) # SImple textfile
	gen_SI_v1
	;;
	2) #SI in CSV format
	gen_SI_v2
	;;
	2) #SI in CSV format
	gen_SI_v2
	;;
	3) #SI in TXT format
	gen_SI_v3
	;;
	*)
	prnt_error
	echo "Error in SI generation. stopping"
	exit
	;;
esac






#console output
case $VERBOSITY in
	0)
	ENERG_EL_FORM=`echo "$ENERG_EL" | cut -c -10 `
	printf '%-25s | %-10s | %-8s | %-9s | %-1s | %-1s | %-8s | %-30s \n' $FILENAMFORMATTED $ENERG_EL_FORM $ZPVE $GIBBS $NTERM $IMAG $PROGNAME $NOTES
	#echo " $FILENAMFORMATTED $ENERG_EL_FORM $ZPVE $GIBBS $NTERM $IMAG $PROGNAME $NOTES "
	;;
	1)
	echo "$ENERG_EL $ZPVE $ENERG_THERM $ENTHALPY $GIBBS"	#TIZIAN
	;;
esac

# CSV Output

echo "$FULLPATH;$FILENAME;$METH;$BASIS;$ENERG_EL;$ZPVE;$ENERG_THERM;$ENTHALPY;$GIBBS;$IMAG;$NTERM;$PROG;$REV;$RUNTIME;$NOTES" >> $CSVFILEFILEPATH


done

######################################################
#post processing of the csv file
#change the CSV delimiter


if [ "$CSVDELIM" != ";" ]
then
	cp $CSVFILEFILEPATH $CSVFILEFILEPATH_BKUP
	awk '$1=$1' FS=";" OFS="$CSVDELIM" $CSVFILEFILEPATH_BKUP > $CSVFILEFILEPATH
fi

#change the decimal seperator

if [ "DECISEP" != "." ]
then
	cp $CSVFILEFILEPATH $CSVFILEFILEPATH_BKUP
	sed "s/\./$DECISEP/g" $CSVFILEFILEPATH_BKUP > $CSVFILEFILEPATH
	#awk '$1=$1' FS=";" OFS="$CSVDELIM" $CSVFILEFILEPATH_BKUP > $CSVFILEFILEPATH
fi



# printf '%3s\t%-14s\t%-14s\t%-14s\n' $COORDS
