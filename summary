#!/bin/bash
#
# create summarys of your computations 
#
# version history:
#
# version 0.1: (19.01.2018) 
# Tizian MÃ¼ller: 
# - basic stuff with gaussian .out-Files
# script is not fully tested. Use at your own risk
# please report any bugs and suggestions via mail or during cigarette breaks
#




# difine variables
VERSION="0.1"
USERFILEPATH=`whoami`
DIR=`pwd`
#default settings: these may be changed by some arguments
CSVFILEFILEPATH="summary.csv"
CSVFILEFILEPATH_BKUP="summary_bkup.csv"
CSVDELIM=";"
DECISEP="."
SCRIPTDIR=`dirname $(readlink -f ${0})`
MAXFILES=25 # maximal files summary will read without extra user input
DEPTH=all #depth of search -1=all 0=current n=n subfolders
VERBOSITY=0 # verbosity of the output on terminal
NOTES="none" # all kind of notes are kept in here

function prnt_error {
echo -e  "\033[0;31m ERROR ! stopping script \033[0m "
}

function prnt_warning {
echo -e "\033[1;33m WARNING ! \033[0m "
}

function prnt_ok {
echo -e -n "\033[0;32m OK: \033[0m "
}

## here schould be some sort of check for arguments

while getopts ":hd:s:cn:v" OPTION; do
  case $OPTION in
    h) 
	vim $SCRIPTDIR/help_summary.txt  
	exit
	;;
	d)
	CSVDELIM=$OPTARG
	;;
	s)
	DECISEP=$OPTARG
	;;
	c)
	DEPTH=0
	;;
	n)
	DEPTH=$OPTARG
	;;
	v)
	VERBOSITY=1
	;;
    \?)
	prnt_error
    echo "Invalid option: -$OPTARG" >&2
	echo "For Help type: sumary -h"
	exit
    ;;
  esac
done



# show welcome message
echo -n "summary version $VERSION    "


#Defining the depth of search
case $DEPTH in
	all)
	LIST=`find -name "*.out"`
	echo "... searching in all subfolders"
	;;
	0)
	LIST=`ls -la | grep ".out" | awk '{print $9}'`
	echo "... searching in only the currend folder"
	;;
	*)
	echo "... searching this and $DEPTH subfolders"
	DEPTH=`echo "$DEPTH + 1"  | bc`
	LIST=`find -maxdepth $DEPTH -name "*.out"`
	;;
esac

LISTARR=($LIST)


# asks for user reply if too much files are found

if [ ${#LISTARR[@]} -gt $MAXFILES ]
then
	prnt_warning
	echo "found a large amount of OUT files"
	echo "${#LISTARR[@]} / $MAXFILES"
	read -p "Do you want to proceed ? " -n 1 -r 
		case $REPLY in
        [Yy]* ) echo "  OK";;
        [Nn]* ) echo ""; exit;;
        * ) echo "  Please answer Y or N."; exit ;;
        esac
else echo "found ${#LISTARR[@]} OUT files ... starting now"
fi


######################################################
#            Functions for reading various stuff

function format_strings { # formats stuff like the full path to the file, the dir in which the file is stored and the filename
FILENAME=`echo " $FILEPATH" | sed -e 's@\/@ @g' | awk '{print $NF}'`
FILENAMFORMATTED=`echo "$FILENAME" | cut -c -24 `

FULLPATH=$FILEPATH 
}

function ident_prog { # identify the programm (gaussian, orca, ...) that created this OUT file
#orca:
FILEHEAD=`head -3 $FILEPATH `
IDENTORCA=`echo "$FILEHEAD"| grep -c "        * O   R   C   A *"`
IDENTGAUSSIAN=`echo "$FILEHEAD"| grep -c " Entering Gaussian System, Link 0"`

PROGID=0
PROGNAME="none"

if [ "$IDENTORCA" = "0" ] & [ "$IDENTGAUSSIAN" = "1" ]
	then
	PROGNAME="Gaussian"
fi 

if [ "$IDENTORCA" = "1" ] & [ "$IDENTGAUSSIAN" = "0" ]
	then
	PROGNAME="ORCA"
	NOTES="ORCA_not_fully_implemented"
fi
}

function find_methode { # gives the used Method
if [ $PROGNAME = "Gaussian" ]
	then
	RAW=`grep -m 1 "GINC-" $FILEPATH | sed -e 's.\\\. .g'`
	METH=` echo $RAW | awk '{print $5}'`
	BASIS=`echo $RAW | awk '{print $6}'`
fi

}

function find_energ { 
ENERG_EL=`tac $FILEPATH | grep -m 1 "SCF Done:  " | awk '{print $5}'`

if [ $PROGNAME = "ORCA" ]
	then
	ENERG_EL=`grep "FINAL SINGLE POINT ENERGY" $FILEPATH | awk '{print $5}'`
fi

}

function find_ther_corr { # finds the themal corrections for electronic Energy
 ZPVE=`grep "Zero-point correction=" $FILEPATH | awk '{print $3}'`
 RAW=`grep -A 8 "Zero-point correction=" $FILEPATH| awk 'NF>1{print $NF}'`
 RAWARRAY=($RAW)
 
 ENERG_THERM=${RAWARRAY[1]}
 ENTHALPY=${RAWARRAY[2]}
 GIBBS=${RAWARRAY[3]}

#ZPVE=`grep "Zero-point correction=" $FILEPATH | awk '{print $3}'`
#ENERG=`grep "Thermal correction to Energy=" $FILEPATH | awk '{print $5}'`
#ENTHALPY=`grep "Thermal correction to Enthalpy= " $FILEPATH | awk '{print $5}'`
#GIBBS=`grep "Thermal correction to Gibbs Free Energy= " $FILEPATH | awk '{print $7}'`
}

function find_Nimag {
if  [ -z `grep -i -m 1 "imaginary frequencies (negative Signs" $FILEPATH | awk '{print $2}'` ]
then IMAG="0"
else IMAG="`grep -i -m 1 "imaginary frequencies (negative Signs" $FILEPATH | awk '{print $2}'`"
fi
}

function find_NTerm {
 NTERM=`grep -c "Normal termination of Gaussian" $FILEPATH`
}

function find_version {
RAW=`grep -m 1 -A 2 "Cite this work as:" $FILEPATH`
PROG=`echo $RAW | awk '{print $5 $6}' | sed 's/,//g'`
REV=`echo $RAW | awk '{print $8}' | sed 's/,//g'`
}

function find_runtime {
RUNTIME=`tail $FILEPATH | grep " Job cpu time:" | awk '{print $4":"$6":"$8":" $10}'`
}

######################################################
# initialisation of the *.csv files

echo "summary" > $CSVFILEFILEPATH #
echo "user;$USERFILEPATH" >> $CSVFILEFILEPATH
echo "directory;$DIR" >> $CSVFILEFILEPATH
echo "host;$(hostname)" >> $CSVFILEFILEPATH

echo " " >> $CSVFILEFILEPATH

TABLEHEAD="File FILEPATH;method; basisset; E(el); ZP corr.; E corr.; H corr.; G corr.; imaginary frequencies; Normal terminations; programm; Revison; Runtime"

echo "$TABLEHEAD" >> $CSVFILEFILEPATH

######################################################


#table headers for console output
case $VERBOSITY in
	0)
	echo "      FILEPATH            |  E(SCF)/ AU     | NT | Program  |   notes"
	echo "--------------------------+-----------------+----+----------+-------------- "
	#     2_PBE0_D3_def2SVp_SP_DLP  | -1978.39679009  | 0  | ORCA     | none
	;;
	1)
	echo "$FILEPATH $METH $BASIS $ENERG_EL $ZPVE $ENERG_THERM $ENTHALPY $GIBBS $IMAG $NTERM $PROG $REV $RUNTIME"
	;;
esac




# actuale magic happens here
for FILEPATH in "${LISTARR[@]}" ; do

NOTES="none"

ident_prog
format_strings
find_methode
find_energ
find_ther_corr
find_Nimag
find_NTerm
find_version
find_runtime
#FILEPATH=`echo $FILEPATH | sed -e 's/\.//g' `



#console output
case $VERBOSITY in
	0)
	ENERG_EL_FORM=`echo "$ENERG_EL" | cut -c -14 `
	printf '%-25s | %-15s | %-2s | %-8s | %-30s \n' $FILENAMFORMATTED $ENERG_EL_FORM $NTERM $PROGNAME $NOTES | sed 's/ / /g'
	;;
	1)
	echo "$FILEPATH $METH $BASIS $ENERG_EL $ZPVE $ENERG_THERM $ENTHALPY $GIBBS $IMAG $NTERM $PROG $REV $RUNTIME"
	;;
esac

#echo "FILEPATH METH BASIS ENERG ZPVE ENERG ENTHALPY GIBBS"
#echo "$FILEPATH $METH $BASIS $ENERG_EL $ZPVE $ENERG_THERM $ENTHALPY $GIBBS $IMAG $NTERM $PROG $REV $RUNTIME"

# CSV Output

echo "$FILEPATH;$METH;$BASIS;$ENERG_EL;$ZPVE;$ENERG_THERM;$ENTHALPY;$GIBBS;$IMAG;$NTERM;$PROG;$REV;$RUNTIME" >> $CSVFILEFILEPATH

done

######################################################
#post processing of the csv file
#change the CSV delimiter


if [ "$CSVDELIM" != ";" ]
then
	cp $CSVFILEFILEPATH $CSVFILEFILEPATH_BKUP
	awk '$1=$1' FS=";" OFS="$CSVDELIM" $CSVFILEFILEPATH_BKUP > $CSVFILEFILEPATH
fi

#change the decimal seperator

if [ "DECISEP" != "." ]
then
	cp $CSVFILEFILEPATH $CSVFILEFILEPATH_BKUP
	sed "s/\./$DECISEP/g" $CSVFILEFILEPATH_BKUP > $CSVFILEFILEPATH
	#awk '$1=$1' FS=";" OFS="$CSVDELIM" $CSVFILEFILEPATH_BKUP > $CSVFILEFILEPATH
fi







